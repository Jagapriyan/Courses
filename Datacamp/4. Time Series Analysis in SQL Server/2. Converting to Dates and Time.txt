Dates From Parts

SQL Server has six functions to build dates and times from component parts: the from parts series

The DATEFROMPARTS() function allows us to turn a series of numbers representing date parts into a valid DATE data type.
DATEFROMPARTS(year, month, day) - it takes integer values for year, month, and day and returns a 'DATE' type. 

TIMEFROMPARTS(hour, minute, second, fraction, precision) - it takes integer values for hour, minute, second, fraction of a second and precision from 0 to 7 -- and returns the appropriate 'TIME' datatype

The calssic 'DATETIME' datatype has its own function. 
DATETIMEFROMPARTS(year, month, day, hour, minute, second, ms) - goes down to 3-millisecond granularity

DATETIME2FROMPARTS(year, month, day, hour, minute, second, fraction, precision) - Can be used for More precision. Note that its inputs are the set combination of 'DATEFROMPARTS()' and 'DATETIMEFROMPARTS()'

SMALLDATETIMEFROMPARTS(year, month, day, hour, minute) - it is not used as much now. as it is a legacy one. DATETIME2 is used instead. 

DATETIMEOFFSETFROMPARTS(year, month, day, hour, minute, second, fraction, hour_offset, minute_offset, precision) - takes the 'DATETIME2' fields and adds inputs for the hour and minute offsets from UTC time so you can specify the time zone as well as time. 
For example, Indian time is 5 1/2 hours ahead of UTC. we can represent this in SQL server using the DATETIMEOFFSETFROMPARTS() function, passing in 5 hours and 30minutes as the offset values. 

We can also take this offset and bring it to another time zone using the 'AT TIME ZONE' operator. 
EX:
SELECT 
	DATETIMEOFFSETFROMPARTS(2009, 08, 14, 21, 00, 00, 0, 5, 30, 0) AS IST,
	DATETIMEOFFSETFROMPARTS(2009, 08, 14, 21, 00, 00, 0, 5, 30, 0) AT TIME ZONE 'UTC' AS UTC;
	
	The output will be 
	
	IST										UTC
2009-08-14 21:00:00.0000000 +05:30	2009-08-14 15:30:00.0000000 +00:00
	
	
Note
Three things to keep in mind while working with FROMPARTS() series of functions. 

1) If any of the INPUT value is NULL, the result will always be NULL. 
2) If any of the input values is invalid for the date part, we will receive an error message stating that arguments have values which are not valid. This will also pop up if you have a DATETIME with a year before 1753
3) If you set the precision on 'DATETIME2FROMPARTS()' to a number which is smaller than can hold the fraction part of your date, you will receive an error. 



Excercise

Create dates from component parts in the calendar table: calendar year, calendar month, and the day of the month.

-- Create dates from component parts on the calendar table
SELECT TOP(10)
	DATEFROMPARTS(c.CalendarYear, c.CalendarMonth, c.Day) AS CalendarDate
FROM dbo.Calendar c
WHERE
	c.CalendarYear = 2017
ORDER BY
	c.FiscalDayOfYear ASC;

O/p
	
CalendarDate
2017-07-01
2017-07-02
2017-07-03
2017-07-04
2017-07-05
2017-07-06
2017-07-07
2017-07-08
2017-07-09
2017-07-10
	
Create dates from the component parts of the calendar table. Use the calendar year, calendar month, and day of month.

SELECT TOP(10)
	c.CalendarQuarterName,
	c.MonthName,
	c.CalendarDayOfYear
FROM dbo.Calendar c
WHERE
	-- Create dates from component parts
	DATEFROMPARTS(c.CalendarYear, c.CalendarMonth, c.Day) >= '2018-06-01'
	AND c.DayName = 'Tuesday'
ORDER BY
	c.FiscalYear,
	c.FiscalDayOfYear ASC;
	
	
O/p

CalendarQuarterName	MonthName	CalendarDayOfYear
Q2					June			156
Q2					June			163
Q2					June			170
Q2					June			177
Q3					July			184
Q3					July			191
Q3					July			198
Q3					July			205
Q3					July			212
Q3					August			219



Build dates and times from parts

SQL Server has several functions for generating date and time combinations from parts. In this exercise, we will look at DATETIME2FROMPARTS() and DATETIMEFROMPARTS().

Neil Armstrong and Buzz Aldrin landed the Apollo 11 Lunar Module--nicknamed The Eagle--on the moon on July 20th, 1969 at 20:17 UTC. 
They remained on the moon for approximately 21 1/2 hours, taking off on July 21st, 1969 at 18:54 UTC.

SELECT
	-- Mark the date and time the lunar module touched down
    -- Use 24-hour notation for hours, so e.g., 9 PM is 21
	DATETIME2FROMPARTS(1969, 7, 20, 20, 17, 00, 000, 0) AS TheEagleHasLanded,
	-- Mark the date and time the lunar module took back off
    -- Use 24-hour notation for hours, so e.g., 9 PM is 21
	DATETIMEFROMPARTS(1969, 7, 21, 18, 54, 00, 000) AS MoonDeparture;
	


Build dates and times with offsets from parts

On January 19th, 2038 at 03:14:08 UTC (that is, 3:14:08 AM), we will experience the Year 2038 (or Y2.038K) problem. 
This is the moment that 32-bit devices will reset back to the date 1900-01-01. This runs the risk of breaking every 32-bit device using POSIX time, which is the number of seconds elapsed since January 1, 1970 at midnight UTC.


Build a DATETIMEOFFSET which represents the last millisecond before the Y2.038K problem hits. The offset should be UTC.
Build a DATETIMEOFFSET which represents the moment devices hit the Y2.038K issue in UTC time. Then use the AT TIME ZONE operator to convert this to Eastern Standard Time.



SELECT
	-- Fill in the millisecond PRIOR TO chaos
	DATETIMEOFFSETFROMPARTS(2038, 01, 19, 03, 14, 07, 999, 0, 0, 3) AS LastMoment,
    -- Fill in the date and time when we will experience the Y2.038K problem
    -- Then convert to the Eastern Standard Time time zone
	DATETIMEOFFSETFROMPARTS(2038, 01, 19, 03, 14, 08, 0, 0, 0, 3) AT TIME ZONE 'Eastern Standard Time' AS TimeForChaos;

LastMoment									TimeForChaos
2038-01-19 03:14:07.9990000 +00:00	2038-01-18 22:14:08.0000000 -05:00




Translating date Strings

The common senario is we want to translate strings to date when we read data from CSVs or external sources. 


CAST()

CAST() is ANSI standard and fast. It uses English as a locale and the format is MM-DD-YYYY.


SELECT 
	CAST('09/14/1999' AS DATE) AS USDate;
	

Converting Strings: CONVERT() Function

JUST like CAST(), CONVERT() serves multiple purposes and allows us to take a string and turn it into a date type. 
EX:

SELECT
	CONVERT(DATETIME2(3), 'April 4, 2019 11:52:29.998 PM') AS April4

In this case, we convert a long string date to a 'DATETIME2' with a precision of 1 millisecond. 
CONVERT() is not an ANSI standard. So it is better to use CAST() instead of CONVERT(). 



Parsing Strings

The PARSE() function lets us translate locale-specific dates. 
It uses .NET framework to perform string translation, which makes it a powerful function. 

EX:

SELECT 
	PARSE ('25 Dezember 2014' AS DATE USING 'de-de') AS Weihnachten;

The output is DATE formate. 
This is not only useful for translating non-default locales but we can handle even strings in your default locale.  



The cost of Parsing

Function	Conversion Per Second
CONVERT()	251,997
CAST()		240,347
PARSE()		12,620


CONVERT() AND CAST() uses same underlying code in SQL server.

It is recommended to use PARSE() for smaller data sets. 


Setting Languages

SET LANGUAGE command is used.

We can use this command to change the language in current session.
This command changes the way SQL server parses strings for dates and displays error and warning messages.

EX:

SET LANGUAGE 'FRENCH'
DECLARE
	@FrenchDate NVARCHAR(30) = N'18 avril 2019',
	@FrenchNumberDate NVARCHAR(30) = N'18/4/2019';

SELECT
	CAST(@FrenchDate AS DATETIME),
	CAST(@FrenchNumberDate AS DATETIME);

2019-04-18 00:00:00.000

These casts would fail in English


Excercises

The CAST() function allows us to turn strings into date and time data types. In this example, we will review many of the formats CAST() can handle.

Review the data in the dbo.Dates table which has been pre-loaded for you. Then use the CAST() function to convert these dates twice: once into a DATE type and once into a DATETIME2(7) type. Because one of the dates includes data down to the nanosecond, we cannot convert to a DATETIME type or any DATETIME2 type with less precision.

NOTE: the CAST() function is language- and locale-specific, meaning that for a SQL Server instance configured for US English, it will translate 08/23/2008 as 2008-08-23 but it will fail on 23/08/2008, which a SQL Server with the French Canadian locale can handle.

Instruction

Cast the input string DateText in the dbo.Dates temp table to the DATE data type.
Cast the input string DateText in the dbo.Dates temp table to the DATETIME2(7) data type.

SELECT
	d.DateText AS String,
	-- Cast as DATE
	CAST(d.DateText AS DATE) AS StringAsDate,
	-- Cast as DATETIME2(7)
	CAST(d.DateText AS DATETIME2(7)) AS StringAsDateTime2
FROM dbo.Dates d;


Convert strings to dates
The CONVERT() function behaves similarly to CAST(). When translating strings to dates, the two functions do exactly the same work under the covers. Although we used all three parameters for CONVERT() during a prior exercise in Chapter 1, we will only need two parameters here: the data type and input expression.

In this exercise, we will once again look at a table called dbo.Dates. This time around, we will get dates in from our German office. In order to handle German dates, we will need to use SET LANGUAGE to change the language in our current session to German. This affects date and time formats and system messages.

Try querying the dbo.Dates table first to see how things differ from the prior exercise.



Use the CONVERT() function to translate DateText into a date data type.
Then use the CONVERT() function to translate DateText into a DATETIME2(7) data type.


SET LANGUAGE 'GERMAN'

SELECT
	d.DateText AS String,
	-- Convert to DATE
	CONVERT(DATE, d.DateText) AS StringAsDate,
	-- Convert to DATETIME2(7)
	CONVERT(DATETIME2(7), d.DateText) AS StringAsDateTime2
FROM dbo.Dates d;



Parse strings to dates
Changing our language for data loading is not always feasible. Instead of using the SET LANGUAGE syntax, we can instead use the PARSE() function to parse a string as a date type using a specific locale.

We will once again use the dbo.Dates table, this time parsing all of the dates as German using the de-de locale.


Parse DateText as dates using the German locale (de-de).
Then, parse DateText as the data type DATETIME2(7), still using the German locale.


SELECT
	d.DateText AS String,
	-- Parse as DATE using German
	PARSE(d.DateText AS DATE USING 'de-de') AS StringAsDate,
	-- Parse as DATETIME2(7) using German
	PARSE(d.DateText AS DATETIME2(7) USING 'de-de') AS StringAsDateTime2
FROM dbo.Dates d;



Working with Offsets

The DATETIME() and DATETIME2() does not have in built concept of timezone.
So a date which reads 3PM might be in UTC or it might be in some other time zone. 

In cases where knowing the time zone is important, SQL server has another date type: the 'DATETIMEOFFSET'.
The DATETIMEOFFSET type is made up of three key components: a date, a time, and a UTC offset.

Anatomy of a DATETIMEOFFSET

Components
Date Part	Example
Date		2019-04-10
Time		12:59:02.3908505
UTC Offset	-04:00

SQL Server will then display the output string with all three components separated by spaces.


Changing offsets

The 'SWITCHOFFSET()' function allows us to change the time zone of a given input string.
If you pass in a 'DATETIME' or 'DATETIME2' SWITCHOFFSET() assumes you are in UTC. 
You can also pass in a 'DATETIMEOFFSET' to move from one known time zone to another.


DECLARE @SomeDate DATETIMEOFFSET = 
	'2019-04-10 12:59:02.3908505 -04:00';
SELECT
	SWITCHOFFSET(@SomeDate, '-7:00') AS LATime;

O/P
LATime
2019-04-10 09:59:02.3908505 -07:00


Though we can use SWITCHOFFSET function to convert 'DATETIME2' data type into a 'DATETIMEOFFSET' 
but there is an easier way if we just need to give the date and time an offset from UTC, and that is the 'TODATETIMEOFFSET()' function. 
This function takes two parameters: an input date and a time zone. From there it generates a DATETIMEOFFSET.


EX:

DECLARE @SomeDate DATETIME2(3) = 
'2019-04-10 12:59:02.390';

SELECT
	TODATETIMEOFFSET(@SomeDate, '-04:00') AS EDT;
	
	
TimeZone Swaps with TODATETIMEOFFSET()
	
This function helps in slightly more complicated scenarios as well. 

Consider a scenario where the server time is Central Easter Time Zone which is UTC-5 and corporate HQ is at UTC+2.
For this we can use DATEADD to put the date as UTC+2 and tell SQL server that the offset is +2.

Ex:

DECLARE @SomeDate DATETIME2(3) = 
	'2016-09-04 02:28:29.681'
SELECT
	TODATETIMEOFFSET(
	DATEADD(HOUR, 7, @SomeDate),
	'+02:00') AS BonnTime;

	
Discovering Time Zones

For 'SWITCHOFFSET()' and 'TODATETIMEOFFSET()', you need to know the offset number. 
If you don't know that, you can look it up using a Dynamic Management view called 'sys.time_zone_info' 
Dynamic Management View (DMV) available to help us: sys.time_zone_info. This searches the set of time zones available on the operating system (in the Windows registry or /usr/share/zoneinfo on Linux or macOS).
This returns time zones and current UTC offsets, making it great for current searches but less great when working with historical data, as there is no way to search for time zones on a particular date. 

EX:

SELECT
	tzi.name,
	tzi.current_utc_offset,
	tzi.is_currently_dst
FROM sys.time_zone_info tzi
WHERE
	tzi.name LIKE '%Time Zone%';


Exercise

Changing a date's offset
We can use the SWITCHOFFSET() function to change the time zone of a DATETIME, DATETIME2, or DATETIMEOFFSET typed date or a valid date string. 
SWITCHOFFSET() takes two parameters: the date or string as input and the time zone offset. 
It returns the time in that new time zone, so 3:00 AM Eastern Daylight Time will become 2:00 AM Central Daylight Time.


The 2016 Summer Olympics in Rio de Janeiro started at 11 PM UTC on August 8th, 2016.
 Starting with a string containing that date and time, we can see what time that was in other locales.
 
 
 Instruction
 
 Fill in the appropriate function call for Brasilia, Brazil.
Fill in the appropriate function call and time zone for Chicago, Illinois. 
In August, Chicago is 2 hours behind Brasilia Standard Time.
Fill in the appropriate function call and time zone for New Delhi, India. 
India does not observe Daylight Savings Time, so in August, New Delhi is 8 1/2 hours ahead of Brasilia Standard Time. 
Note when calculating time zones that Brasilia and New Delhi are on opposite sides of UTC


DECLARE
	@OlympicsUTC NVARCHAR(50) = N'2016-08-08 23:00:00';

SELECT
	-- Fill in the time zone for Brasilia, Brazil
	SWITCHOFFSET(@OlympicsUTC, '-03:00') AS BrasiliaTime,
	-- Fill in the time zone for Chicago, Illinois
	SWITCHOFFSET(@OlympicsUTC, '-05:00') AS ChicagoTime,
	-- Fill in the time zone for New Delhi, India
	SWITCHOFFSET(@OlympicsUTC, '+05:30') AS NewDelhiTime;
	
	
BrasiliaTime								ChicagoTime							NewDelhiTime
2016-08-08 20:00:00.0000000 -03:00	2016-08-08 18:00:00.0000000 -05:00	2016-08-09 04:30:00.0000000 +05:30




Converting to a date offset
In addition to SWITCHOFFSET(), we can use the TODATETIMEOFFSET() to turn an existing date into a date type with an offset. 
If our starting time is in UTC, we will need to correct for time zone and then append an offset. 
To correct for the time zone, we can add or subtract hours (and minutes) manually.

Closing ceremonies for the 2016 Summer Olympics in Rio de Janeiro began at 11 PM UTC on August 21st, 2016. 
Starting with a string containing that date and time, we can see what time that was in other locales. For the time in Phoenix, Arizona, you know that they observe Mountain Standard Time, which is UTC -7 year-round. The island chain of Tuvalu has its own time which is 12 hours ahead of UTC.



DECLARE
	@OlympicsClosingUTC DATETIME2(0) = '2016-08-21 23:00:00';

SELECT
	-- Fill in 7 hours back and a '-07:00' offset
	TODATETIMEOFFSET(DATEADD(HOUR, -7, @OlympicsClosingUTC), '-07:00') AS PhoenixTime,
	-- Fill in 12 hours forward and a '+12:00' offset.
	TODATETIMEOFFSET(DATEADD(HOUR, +12, @OlympicsClosingUTC), '+12:00') AS TuvaluTime;
	
	
	PhoenixTime							TuvaluTime
2016-08-21 16:00:00.0000000 -07:00	2016-08-22 11:00:00.0000000 +12:00


Excercise

Try out type-safe date functions
In this exercise, we will try out the TRY_CONVERT(), TRY_CAST(), and TRY_PARSE() set of functions. 
Each of these functions will safely parse string data and attempt to convert to another type, returning NULL if the conversion fails. 
Conversion to, e.g., a date type can fail for several reasons. 
If the input string is not a date, conversion will fail. If the input type is in a potentially ambiguous format, conversion might fail. 
An example of this is the date 04/01/2019 which has a different meaning in the United States (April 1, 2019) versus most European countries (January 4th, 2019).



Starting with the TRY_CONVERT() function, fill in the function name and input parameter for each example.


DECLARE
	@GoodDateINTL NVARCHAR(30) = '2019-03-01 18:23:27.920',
	@GoodDateDE NVARCHAR(30) = '13.4.2019',
	@GoodDateUS NVARCHAR(30) = '4/13/2019',
	@BadDate NVARCHAR(30) = N'SOME BAD DATE';

SELECT
	-- Fill in the correct data type based on our input
	TRY_CONVERT(DATETIME2(3), @GoodDateINTL) AS GoodDateINTL,
	-- Fill in the correct function
	TRY_CONVERT(DATE, @GoodDateDE) AS GoodDateDE,
	TRY_CONVERT(DATE, @GoodDateUS) AS GoodDateUS,
	-- Fill in the correct input parameter for BadDate
	TRY_CONVERT(DATETIME2(3), @BadDate) AS BadDate;
	
	
	GoodDateINTL			GoodDateDE	GoodDateUS	BadDate
2019-03-01 18:23:27.920000		null	2019-04-13	null


With the prior TRY_CONVERT() solution in mind, use TRY_CAST() to see how they compare.

DECLARE
	@GoodDateINTL NVARCHAR(30) = '2019-03-01 18:23:27.920',
	@GoodDateDE NVARCHAR(30) = '13.4.2019',
	@GoodDateUS NVARCHAR(30) = '4/13/2019',
	@BadDate NVARCHAR(30) = N'SOME BAD DATE';

-- The prior solution using TRY_CONVERT
SELECT
	TRY_CONVERT(DATETIME2(3), @GoodDateINTL) AS GoodDateINTL,
	TRY_CONVERT(DATE, @GoodDateDE) AS GoodDateDE,
	TRY_CONVERT(DATE, @GoodDateUS) AS GoodDateUS,
	TRY_CONVERT(DATETIME2(3), @BadDate) AS BadDate;

SELECT
	-- Fill in the correct data type based on our input
	TRY_CAST(@GoodDateINTL AS DATETIME2(3)) AS GoodDateINTL,
    -- Be sure to match these data types with the
    -- TRY_CONVERT() examples above!
	TRY_CAST(@GoodDateDE AS DATE) AS GoodDateDE,
	TRY_CAST(@GoodDateUS AS DATE) AS GoodDateUS,
	TRY_CAST(@BadDate AS DATETIME2(3)) AS BadDate;
	

GoodDateINTL				GoodDateDE	GoodDateUS	BadDate
2019-03-01 18:23:27.920000		null	2019-04-13	null

One of our good dates returns NULL. Use TRY_PARSE() and specify de-de for the German date and en-us for the US date.



SELECT
	TRY_PARSE(@GoodDateINTL AS DATETIME2(3)) AS GoodDateINTL,
    -- Fill in the correct region based on our input
    -- Be sure to match these data types with the
    -- TRY_CAST() examples above!
	TRY_PARSE(@GoodDateDE AS DATE USING 'de-de') AS GoodDateDE,
	TRY_PARSE(@GoodDateUS AS DATE USING 'en-us') AS GoodDateUS,
    -- TRY_PARSE can't fix completely invalid dates
	TRY_PARSE(@BadDate AS DATETIME2(3) USING 'sk-sk') AS BadDate;
	
	GoodDateINTL			GoodDateDE	GoodDateUS	BadDate
2019-03-01 18:23:27.920000	2019-04-13	2019-04-13	null


Convert imported data to dates with time zones
Now that we have seen the three type-safe conversion functions, we can begin to apply them against real data sets. In this scenario, we will parse data from the dbo.ImportedTime table. We used a different application to load data from this table and looked at it in a prior exercise. This time, we will retrieve data for all rows, not just the ones the importing application marked as valid.


Fill in the missing TRY_XXX() function name inside the EventDates common table expression.
Convert the EventDateOffset event dates to 'UTC'. Call this output EventDateUTC.
Convert the EventDateOffset event dates to 'US Eastern Standard Time' using AT TIME ZONE. Call this output EventDateUSEast.



WITH EventDates AS
(
    SELECT
        -- Fill in the missing try-conversion function
        TRY_CONVERT(DATETIME2(3), it.EventDate) AT TIME ZONE it.TimeZone AS EventDateOffset,
        it.TimeZone
    FROM dbo.ImportedTime it
        INNER JOIN sys.time_zone_info tzi
			ON it.TimeZone = tzi.name
)
SELECT
    -- Fill in the approppriate event date to convert
	CONVERT(NVARCHAR(50), ed.EventDateOffset) AS EventDateOffsetString,
	CONVERT(DATETIME2(0), ed.EventDateOffset) AS EventDateLocal,
	ed.TimeZone,
    -- Convert from a DATETIMEOFFSET to DATETIME at UTC
	CAST(ed.EventDateOffset AT TIME ZONE 'UTC' AS DATETIME2(0)) AS EventDateUTC,
    -- Convert from a DATETIMEOFFSET to DATETIME with time zone
	CAST(ed.EventDateOffset AT TIME ZONE 'US Eastern Standard Time'  AS DATETIME2(0)) AS EventDateUSEast
FROM EventDates ed;

EventDateOffsetString	EventDateLocal	TimeZone	EventDateUTC	EventDateUSEast
2019-04-08 08:00:00.000 +09:30	2019-04-08 08:00:00	Cen. Australia Standard Time	2019-04-07 22:30:00	2019-04-07 18:30:00
2019-04-08 08:00:00.000 -04:00	2019-04-08 08:00:00	US Eastern Standard Time	2019-04-08 12:00:00	2019-04-08 08:00:00
2019-04-08 08:00:00.000 +08:00	2019-04-08 08:00:00	China Standard Time	2019-04-08 00:00:00	2019-04-07 20:00:00
2019-04-08 08:00:00.000 +01:00	2019-04-08 08:00:00	Morocco Standard Time	2019-04-08 07:00:00	2019-04-08 03:00:00
null	null	Morocco Standard Time	null	null


Test type-safe conversion function performance
In the last two exercises, we looked at the TRY_CAST(), TRY_CONVERT(), and TRY_PARSE() functions. These functions do not all perform equally well. In this exercise, you will run a performance test against all of the dates in our calendar table.

To make it easier, we have pre-loaded dates in the dbo.Calendar table into a temp table called DateText, where there is a single NVARCHAR(50) column called DateText.

For the first three steps, the instructions will be the same: fill in missing values to complete the relevant function call. After doing that, observe the amount of time each operation takes and keep the results in mind. You will then summarize your results in step 4.



Fill in the correct conversion function based on its parameter signature.
Note the amount of time returned in the DATEDIFF() call.
Do not use @StartTimeCast or @EndTimeCast in your answer; these are for calculating execution time.

-- Try out how fast the TRY_CAST() function is
-- by try-casting each DateText value to DATE
DECLARE @StartTimeCast DATETIME2(7) = SYSUTCDATETIME();
SELECT TRY_CAST(DATETEXT AS DATE) AS TestDate FROM #DateText;
DECLARE @EndTimeCast DATETIME2(7) = SYSUTCDATETIME();

-- Determine how much time the conversion took by
-- calculating the date difference from @StartTimeCast to @EndTimeCast
SELECT
    DATEDIFF(MILLISECOND, @StartTimeCast, @EndTimeCast) AS ExecutionTimeCast;
	
	ExecutionTimeCast
4


Fill in the correct conversion function based on its parameter signature.
Note the amount of time returned in the DATEDIFF() call.
Do not use @StartTimeCast or @EndTimeCast in your answer; these are for calculating execution time.



-- Try out how fast the TRY_CONVERT() function is
-- by try-converting each DateText value to DATE
DECLARE @StartTimeConvert DATETIME2(7) = SYSUTCDATETIME();
SELECT TRY_CONVERT(DATE, DateText) AS TestDate FROM #DateText;
DECLARE @EndTimeConvert DATETIME2(7) = SYSUTCDATETIME();

-- Determine how much time the conversion took by
-- calculating the difference from start time to end time
SELECT
    DATEDIFF(MILLISECOND, @StartTimeConvert, @EndTimeConvert) AS ExecutionTimeConvert;
	


ExecutionTimeConvert
8



Fill in the correct conversion function based on its parameter signature.
Note the amount of time returned in the DATEDIFF() call.
Do not use @StartTimeCast or @EndTimeCast in your answer; these are for calculating execution time.



-- Try out how fast the TRY_PARSE() function is
-- by try-parsing each DateText value to DATE
DECLARE @StartTimeParse DATETIME2(7) = SYSUTCDATETIME();
SELECT TRY_PARSE(DateText AS DATE) AS TestDate FROM #DateText;
DECLARE @EndTimeParse DATETIME2(7) = SYSUTCDATETIME();

-- Determine how much time the conversion took by
-- calculating the difference from start time to end time
SELECT
    DATEDIFF(MILLISECOND, @StartTimeParse, @EndTimeParse) AS ExecutionTimeParse;
	
	
	ExecutionTimeParse
559


