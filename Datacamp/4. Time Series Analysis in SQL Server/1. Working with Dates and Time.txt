Building Dates


GETDATE() AND 
GETUTCDATE() will return a date, in local or UTC time respectively, as a DATETIME data type. 

SYSDATETIME() AND
SYSUTCDATETIME() will return the current time-either local or UTC--as a DATETIME2 typed response. 


Breaking Down a date

Suppose we don't need an entire date and time but only want a specific part. 
We can get the year, the month or the day. 



EX:
DECLARE
	@SomeDate DATETIME2(3) = '2019=03-01 08:17:19.322';
	
SELECT YEAR(@SomeDate)
SELECT MONTH(@SomeDate)
SELECT DAY(@SomeDate)


YEAR = 2019
MONTH = 2
DAY = 1

PARSING Dates with Date Parts

The DATEPART() AND DATETIME() functions give us much more control over our date parts. 
DATEPART() returns the numeric value of the part we want, such as the year. 
These functions can shred date into a number of component parts.  

SELECT
	DATEPART (YEAR, @dt) AS TheYear;
	
Example

DECLARE 
	@CurrentDate DATETIME2(7) = GETDATE()
SELECT 
	YEAR (@CurrentDate) AS CurrentYear,
	DATEPART(YEAR, @CurrentDate) AS CurrentYear1,
	DATEPART(DAY, @CurrentDate) AS Day,
	DATEPART(HOUR, @CurrentDate) AS Hour;
	
Output

CurrentYear	CurrentYear1	Day		Hour
2021		2021			9		11
	

DATENAME() gives us a string value, important if we want to know the name of the month. 

SELECT 
	DATENAME(MONTH, @dt) AS TheMonth
	

we can get the year, month and day like standalore functions.
We can also get the day of the year, day of the week, week of the year, ISO Week of the year - a format which is used mostly in Europe, minutes, seconds, milliseconds or even down to nanoseconds. 


Date Arithmetic

We can also add and subtract dates with the DATEADD() function
We can even chain these function calls together for additional precision.

Syntax

DATEADD (datepart , number , date) 


DECLARE
	@SomeTime DATETIME2(7) = '1992-07-14 14:49:36.2294852'

SELECT
	DATEADD(DAY, 1, @SomeTime) AS NextDay,
	DATEADD(DAY, -1, @SomeTime) AS PreviousDay;
SELECT
	DATEADD(HOUR, -3, DATEADD(DAY, -4, @SomeTime)) AS Minus4Days3Hours;
	

Example2

DECLARE
	@CurrentDate DATETIME2(7) = GETDATE()

SELECT
	DATEADD(DAY,1, @CurrentDate ) AS NextDate,
	DATEADD(DAY, -1, @CurrentDate) AS PreviousDate
	
	
NextDate						PreviousDate
2021-11-10 12:04:49.900000	2021-11-08 12:04:49.900000	



Comparing dates

The DATEDIFF() function allows us to compare the number of units of time between two date or time types. 
Suppose, if we know the start and end time for a machine we can easily calculate the time elapsed. 
Note that DATEDIFF() returns an integer and rounds up.  

Syntax

DATEDIFF(interval, date1, date2)

Ex:

DECLARE
	@StartTime  DATETIME2(7) = '2012-03-01 14:29:36'
	@EndTime DATETIME2(7) = '2012-03-01 18:00:00'

SELECT
	DATEDIFF(SECOND, @StartTime, @EndTime) AS SecondsElapsed,
	DATEDIFF(MINUTE, @StartTime, @EndTime) AS MinutesElapsed,
	DATEDIFF(HOUR, @StartTime, @EndTime) AS HoursElapsed;
	

Excercise

Break a date and time into component parts

Use the YEAR(), MONTH(), and DAY() functions to determine the year, month, and day for the current date and time.

DECLARE
	@SomeTime DATETIME2(7) = SYSUTCDATETIME();

-- Retrieve the year, month, and day
SELECT
	YEAR(@SomeTime) AS TheYear,
	MONTH(@SomeTime) AS TheMonth,
	DAY(@SomeTime) AS TheDay;
	
	



Using the DATEPART() function, fill in the appropriate date parts. For a list of parts, review https://docs.microsoft.com/en-us/sql/t-sql/functions/datepart-transact-sql


DECLARE
	@BerlinWallFalls DATETIME2(7) = '1989-11-09 23:49:36.2294852';

-- Fill in each date part
SELECT
	DATEPART(YEAR   , @BerlinWallFalls) AS TheYear,
	DATEPART(MONTH, @BerlinWallFalls) AS TheMonth,
	DATEPART(DAY, @BerlinWallFalls) AS TheDay,
	DATEPART(DAYOFYEAR, @BerlinWallFalls) AS TheDayOfYear,
    -- Day of week is WEEKDAY
	DATEPART(WEEKDAY, @BerlinWallFalls) AS TheDayOfWeek,
	DATEPART(WEEK, @BerlinWallFalls) AS TheWeek,
	DATEPART(SECOND, @BerlinWallFalls) AS TheSecond,
	DATEPART(NANOSECOND, @BerlinWallFalls) AS TheNanosecond;

Using the DATENAME() function, fill in the appropriate function calls.

DECLARE
	@BerlinWallFalls DATETIME2(7) = '1989-11-09 23:49:36.2294852';

-- Fill in the function to show the name of each date part
SELECT
	DATENAME(YEAR, @BerlinWallFalls) AS TheYear,
	DATENAME(MONTH, @BerlinWallFalls) AS TheMonth,
	DATENAME(DAY, @BerlinWallFalls) AS TheDay,
	DATENAME(DAYOFYEAR, @BerlinWallFalls) AS TheDayOfYear,
    -- Day of week is WEEKDAY
	DATENAME(WEEKDAY, @BerlinWallFalls) AS TheDayOfWeek,
	DATENAME(WEEK, @BerlinWallFalls) AS TheWeek,
	DATENAME(SECOND, @BerlinWallFalls) AS TheSecond,
	DATENAME(NANOSECOND, @BerlinWallFalls) AS TheNanosecond;
	
	
	
Date math and leap years
Fill in the date parts and intervals needed to determine how SQL Server works on February 29th of a leap year.

2012 was a leap year. The leap year before it was 4 years earlier, and the leap year after it was 4 years later.

DECLARE
	@LeapDay DATETIME2(7) = '2012-02-29 18:00:00';

-- Fill in the date parts and intervals as needed
SELECT
	DATEADD(DAY, -1, @LeapDay) AS PriorDay,
	DATEADD(DAY, 1, @LeapDay) AS NextDay,
    -- For leap years, we need to move 4 years, not just 1
	DATEADD(YEAR, -4, @LeapDay) AS PriorLeapYear,
	DATEADD(YEAR, 4, @LeapDay) AS NextLeapYear,
	DATEADD(YEAR, -1, @LeapDay) AS PriorYear;
	
	
Fill in the date parts and intervals needed to determine how SQL Server works on days next to a leap year.

DECLARE
	@PostLeapDay DATETIME2(7) = '2012-03-01 18:00:00';

-- Fill in the date parts and intervals as needed
SELECT
	DATEADD(DAY, -1, @PostLeapDay) AS PriorDay,
	DATEADD(DAY, 1, @PostLeapDay) AS NextDay,
	DATEADD(YEAR, -4, @PostLeapDay) AS PriorLeapYear,
	DATEADD(YEAR, 4, @PostLeapDay) AS NextLeapYear,
	DATEADD(YEAR, -1, @PostLeapDay) AS PriorYear,
    -- Move 4 years forward and one day back
	DATEADD(DAY, -1, DATEADD(YEAR, 4, @PostLeapDay)) AS NextLeapDay,
    DATEADD(DAY, -2, @PostLeapDay) AS TwoDaysAgo;
	
	
Taking TwoDaysAgo from the prior step, use the DATEDIFF() function to test how it handles leap years.

DECLARE
	@PostLeapDay DATETIME2(7) = '2012-03-01 18:00:00',
    @TwoDaysAgo DATETIME2(7);

SELECT
	@TwoDaysAgo = DATEADD(DAY, -2, @PostLeapDay);

SELECT
	@TwoDaysAgo AS TwoDaysAgo,
	@PostLeapDay AS SomeTime,
    -- Fill in the appropriate function and date types
	DATEDIFF(DAY, @TwoDaysAgo, @PostLeapDay) AS DaysDifference,
	DATEDIFF(HOUR, @TwoDaysAgo, @PostLeapDay) AS HoursDifference,
	DATEDIFF(MINUTE, @TwoDaysAgo, @PostLeapDay) AS MinutesDifference;
	
	
	
Rounding dates
SQL Server does not have an intuitive way to round down to the month, hour, or minute. 
You can, however, combine the DATEADD() and DATEDIFF() functions to perform this rounding.

To round the date 1914-08-16 down to the year, we would call DATEADD(YEAR, DATEDIFF(YEAR, 0, '1914-08-16'), 0).
To round that date down to the month, we would call DATEADD(MONTH, DATEDIFF(MONTH, 0, '1914-08-16'), 0). 
This works for several other date parts as well.



Use DATEADD() and DATEDIFF() in conjunction with date parts to round down our time to the day, hour, and minute.


Syntax

DATEADD (datepart, number, date) 


Syntax

DATEDIFF(interval, date1, date2)



DECLARE
	@SomeTime DATETIME2(7) = '2018-06-14 16:29:36.2248991';

-- Fill in the appropriate functions and date parts
SELECT
	DATEADD(DAY, DATEDIFF(DAY, 0, @SomeTime), 0) AS RoundedToDay,
	DATEADD(HOUR, DATEDIFF(HOUR, 0, @SomeTime), 0) AS RoundedToHour,
	DATEADD(MINUTE, DATEDIFF(MINUTE, 0, @SomeTime), 0) AS RoundedToMinute;
	
	
Query Result
RoundedToDay			RoundedToHour			RoundedToMinute
2018-06-14 00:00:00		2018-06-14 16:00:00		2018-06-14 16:29:00



Formatting dates for reporting


SQL Server has three formatting options available to us:

CAST()

Useful for converting one data type to another data type, including date types. 
No Control over formatting from dates to strings
ANSI SQL standard, meaning any relational and most non-relational databases have this function. 

Ex

DECLARE

	@SomeDate DATETIME2(3) = '1991-06-04 08:00:09',
	@SomeString NVARCHAR(30) = '1991-06-04 08:00:09',
	@OldDateTime DATETIME = '1991-06-04 08:00:09';
	
SELECT
	CAST (@SomeDate AS NVARCHAR(30)) AS DateToString,
	CAST (@SomeString AS DATETIME2(3)) AS StringToDate,
	CAST (@OldDateTime AS NVARCHAR(30)) AS OldDateToString;


CONVERT()

Useful for converting one data type to another data type, including date types
Some Control over formatting from dates to strings using the style parameter 
Specific T-SQL 


CONVERT(data_type(length), expression, style)

refer: https://www.w3schools.com/sql/func_sqlserver_convert.asp


Ex:

DECLARE

	@SomeDate DATETIME2(3) = '1991-06-04 08:00:09';
	
SELECT 
	CONVERT(NVARCHAR(30), @SomeDate, 0) AS DefaultForm,
	CONVERT(NVARCHAR(30), @SomeDate, 1) AS US_mdy,
	CONVERT(NVARCHAR(30), @SomeDate, 101) AS US_mdyyyy,
	CONVERT(NVARCHAR(30), @SomeDate, 120) AS ODBC_sec;

FORMAT()

Useful for formatting a date or number in a particular way for reporting.
Much more felxiblility over formatting from dates to strings than either CAST() or CONVERT()
Specific to T-SQL
Uses .Net framework for conversion
Can be slower as you process more rows as it is single threaded. 

FORMAT(value, format, culture)

Ex:

DECLARE

	@SomeDate DATETIME2(3) = '1991-06-04 08:00:09';
	
SELECT 
	FORMAT(@SomeDate, 'd', 'en-US') AS US_d,
	FORMAT(@SomeDate, 'd', 'de-DE') AS DE_d,
	FORMAT(@SomeDate, 'D', 'de-DE') AS DE_D,
	FORMAT(@SomeDate, 'yyyy-MM-dd') AS yMd;
	
	
Excercise

Fill in the appropriate function, CAST(), for each example.
Using the aliases as a guide, fill in the appropriate variable for each example.



DECLARE
	@CubsWinWorldSeries DATETIME2(3) = '2016-11-03 00:30:29.245',
	@OlderDateType DATETIME = '2016-11-03 00:30:29.245';

SELECT
	-- Fill in the missing function calls
	CAST(@CubsWinWorldSeries AS DATE) AS CubsWinDateForm,
	CAST(@CubsWinWorldSeries AS NVARCHAR(30)) AS CubsWinStringForm,
	CAST(@OlderDateType AS DATE) AS OlderDateForm,
	CAST(@OlderDateType AS NVARCHAR(30)) AS OlderStringForm;
	
	
O/P

CubsWinDateForm	CubsWinStringForm			OlderDateForm		OlderStringForm
2016-11-03		2016-11-03 00:30:29.245		2016-11-03			Nov  3 2016 12:30AM


For the inner function, turn the date the Cubs won the World Series into a DATE data type using the CAST() function.
For the outer function, reshape this date as an NVARCHAR(30) using the CAST() function.


DECLARE
	@CubsWinWorldSeries DATETIME2(3) = '2016-11-03 00:30:29.245';

SELECT
	CAST(CAST(@CubsWinWorldSeries AS DATE) AS NVARCHAR(30)) AS DateStringForm;
	
	
O/P

DateStringForm
2016-11-03



Use the CONVERT() function to translate the date the Cubs won the world series into the DATE and NVARCHAR(30) data types.
The functional form for CONVERT() is CONVERT(DataType, SomeValue)


DECLARE
	@CubsWinWorldSeries DATETIME2(3) = '2016-11-03 00:30:29.245';

SELECT
	CONVERT(DATE, @CubsWinWorldSeries) AS CubsWinDateForm,
	CONVERT(NVARCHAR(30), @CubsWinWorldSeries) AS CubsWinStringForm;
	
O/P	

CubsWinDateForm		CubsWinStringForm
2016-11-03			2016-11-03 00:30:29.245





Fill in the correct function call for conversion.
The UK date formats are 3 and 103, representing two-digit year (dmy) and four-digit year (dmyyyy), respectively.
The corresponding US date formats are 1 and 101.


DECLARE
	@CubsWinWorldSeries DATETIME2(3) = '2016-11-03 00:30:29.245';

SELECT
	CONVERT(NVARCHAR(30), @CubsWinWorldSeries, 0) AS DefaultForm,
	CONVERT(NVARCHAR(30), @CubsWinWorldSeries, 3) AS UK_dmy,
	CONVERT(NVARCHAR(30), @CubsWinWorldSeries, 1) AS US_mdy,
	CONVERT(NVARCHAR(30), @CubsWinWorldSeries, 103) AS UK_dmyyyy,
	CONVERT(NVARCHAR(30), @CubsWinWorldSeries, 101) AS US_mdyyyy;
	
DefaultForm		UK_dmy				US_mdy		UK_dmyyyy		US_mdyyyy
Nov  3 2016 	12:30AM	03/11/16	11/03/16	03/11/2016		11/03/2016




Fill in the function and use the 'd' format parameter (note that this is case sensitive!) to format as short dates.
 Also, fill in the culture for Japan, which in the .NET framework is jp-JP (this is not case sensitive).

DECLARE
	@Python3ReleaseDate DATETIME2(3) = '2008-12-03 19:45:00.033';

SELECT
	-- Fill in the function call and format parameter
	FORMAT(@Python3ReleaseDate, 'd', 'en-US') AS US_d,
	FORMAT(@Python3ReleaseDate, 'd', 'de-DE') AS DE_d,
	-- Fill in the locale for Japan
	FORMAT(@Python3ReleaseDate, 'd', 'jp-JP') AS JP_d,
	FORMAT(@Python3ReleaseDate, 'd', 'zh-cn') AS CN_d;
	
US_d		DE_d		JP_d		CN_d
12/3/2008	03.12.2008	12/03/2008	2008/12/3



Use the 'D' format parameter (this is case sensitive!) to build long dates. 
Also, fill in the culture for Indonesia, which in the .NET framework is id-ID.


DECLARE
	@Python3ReleaseDate DATETIME2(3) = '2008-12-03 19:45:00.033';

SELECT
	-- Fill in the format parameter
	FORMAT(@Python3ReleaseDate, 'D', 'en-US') AS US_D,
	FORMAT(@Python3ReleaseDate, 'D', 'de-DE') AS DE_D,
	-- Fill in the locale for Indonesia
	FORMAT(@Python3ReleaseDate, 'D', 'id-ID') AS ID_D,
	FORMAT(@Python3ReleaseDate, 'D', 'zh-cn') AS CN_D;
	
US_D									DE_D						ID_D			CN_D
Wednesday, December 3, 2008	Mittwoch, 3. Dezember 2008	Rabu, 03 Desember 2008		2008年12月3日


Fill in the custom format strings needed to generate the results in preceding comments. 
Use date parts such as yyyy, MM, MMM, and dd. Capitalization is important for the FORMAT() function! See the full list at https://bit.ly/30SGA5a.


DECLARE
	@Python3ReleaseDate DATETIME2(3) = '2008-12-03 19:45:00.033';
    
SELECT
	-- 20081203
	FORMAT(@Python3ReleaseDate, 'yyyyMMdd') AS F1,
	-- 2008-12-03
	FORMAT(@Python3ReleaseDate, 'yyyy-MM-dd') AS F2,
	-- Dec 03+2008 (the + is just a "+" character)
	FORMAT(@Python3ReleaseDate, 'MMM dd+yyyy') AS F3,
	-- 12 08 03 (month, two-digit year, day)
	FORMAT(@Python3ReleaseDate, 'MM yy dd') AS F4,
	-- 03 07:45 2008.00
    -- (day hour:minute year.second)
	FORMAT(@Python3ReleaseDate, 'dd hh:m yyyy.ss') AS F5;
	
F1				F2			F3			F4				F5
20081203	2008-12-03	Dec 03+2008		12 08 03	03 07:45 2008.00



Working with Calendar tables

A calendar table is a table which stores date information for easy retrieval. 
The table has an integer key which represents the date, the date itself, and supporting information for the day. 
Calendar tables are also known in the warehousing world as date dimensions. 
A calendar table is a helpful utility table which you can use to perform date range calculations quickly and efficiently.
This is especially true when dealing with fiscal years, which do not always align to a calendar year, or holidays which may not be on the same date every year.

SELECT *
FROM dbo.Calendar;


Contents of a calendar table

General Columns
DATE
Day Name
Is Weekend

Calendar year
Calendar month
Calendar quarter
Calendar year

Fiscal Year
Fiscal week of year
Fiscal quarter
Fiscal first day of year

Specialized Columns
Holiday name
Lunar details
ISO week of year


This is a table you build once and ideally never update, so it should be treated as warehouse diemnsion and make it as wide as we need.



Building a calendar Table is straightforward: define the columns you need. 
For each day we want to include, we can use built-in functions to get most of the way there. 
It is better to adapt established scripts that are available online for creating calendar tables. 


APPLY() Operator

APPLY() executes a function for each row in a result set



Excercise

In our example company, the fiscal year starts on July 1 of the current calendar year, so Fiscal Year 2019 started on July 1, 2019 and goes through June 30, 2020. 
All of this information is in a table called dbo.Calendar.


Find the dates of all Tuesdays in December covering the calendar years 2008 through 2010.

-- Find Tuesdays in December for calendar years 2008-2010
SELECT
	c.Date
FROM dbo.Calendar c
WHERE
	c.MonthName = 'December'
	AND c.DayName = 'Tuesday'
	AND c.CalendarYear BETWEEN 2008 AND 2010
ORDER BY
	c.Date;
	
O/P	
	
Date
2008-12-02
2008-12-09
2008-12-16
2008-12-23
2008-12-30
2009-12-01
2009-12-08
2009-12-15
2009-12-22
2009-12-29
2010-12-07
2010-12-14
2010-12-21
2010-12-28



Find the dates for fiscal week 29 of fiscal year 2019.


-- Find fiscal week 29 of fiscal year 2019
SELECT
	c.Date
FROM dbo.Calendar c
WHERE
    -- Instead of month, use the fiscal week
	c.FiscalWeekOfYear = 29
    -- Instead of calendar year, use fiscal year
	AND c.FiscalYear = 2019
ORDER BY
	c.Date ASC;
	
	
O/P

Date
2020-01-12
2020-01-13
2020-01-14
2020-01-15
2020-01-16
2020-01-17
2020-01-18


Joining to a calendar table
In the prior exercise, we looked at a new table, dbo.Calendar. 
This table contains pre-calculated date information stretching from January 1st, 2000 through December 31st, 2049. 
Now we want to use this calendar table to filter another table, dbo.IncidentRollup.

The Incident Rollup table contains artificially-generated data relating to security incidents at a fictitious company.

You may recall from prerequisite courses how to join tables. Here's an example of joining to a calendar table:

SELECT
    t.Column1,
    t.Column2
FROM dbo.Table t
    INNER JOIN dbo.Calendar c
        ON t.Date = c.Date;



Fill in the blanks to determine which dates had type 3 incidents during the third fiscal quarter of FY2019.


SELECT 
ir.IncidentDate,
c.FiscalDayOfYear,
c.FiscalWeekOfYear
FROM IncidentRollup ir 
INNER JOIN Calendar c 
ON ir.IncidentDate = c.Date
WHERE ir.IncidentTypeID = 3 AND 
c.FiscalQuarter = 3 AND 
c.FiscalYear = 2019;


Fill in the gaps in to determine type 4 incidents which happened on weekends in FY2019 after fiscal week 30.

SELECT
	ir.IncidentDate,
	c.FiscalDayOfYear,
	c.FiscalWeekOfYear
FROM dbo.IncidentRollup ir
	INNER JOIN dbo.Calendar c
		ON ir.IncidentDate = c.Date
WHERE
    -- Incident type 4
	ir.IncidentTypeID = 4
    -- Fiscal year 2019
	AND c.FiscalYear = 2019
    -- Beyond fiscal week of year 30
	AND c.FiscalWeekOfYear > 30
    -- Only return weekends
	AND c.IsWeekend = 1;
	
	
	IncidentDate	FiscalDayOfYear	FiscalWeekOfYear
2020-02-16	231	34
2020-02-23	238	35
2020-03-21	265	38
2020-03-29	273	40
2020-04-05	280	41
2020-05-23	328	47
2020-06-21	357	52
2020-06-28	364	53
Showing 8 out of 8 rows
